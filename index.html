<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deltarune Ultimate Loadout Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --dr-black: #000000;
            --dr-white: #FFFFFF;
            --dr-cyan: #00FFFF;
            --dr-pink: #FF9CF6;
            --dr-green: #37FF52;
            --dr-purple: #C27EFF;
            --dr-yellow: #FFFF00;
            --dr-grey: #444444;
            --dr-light-grey: #999999;
        }

        body {
            background-color: var(--dr-black);
            color: var(--dr-white);
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            -webkit-font-smoothing: none;
            image-rendering: pixelated;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: var(--dr-yellow);
            text-align: center;
            text-shadow: 2px 2px var(--dr-purple);
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: var(--dr-light-grey);
            font-size: 0.8em;
            margin-bottom: 40px;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .character-card {
            background-color: var(--dr-grey);
            border: 2px solid var(--dr-white);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .character-card h2 {
            margin: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--dr-white);
            text-align: center;
        }
        #kris-header { color: var(--dr-cyan); }
        #susie-header { color: var(--dr-purple); }
        #ralsei-header { color: var(--dr-green); }
        #noelle-header { color: var(--dr-pink); }
        
        .equip-group, .stats-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            color: var(--dr-yellow);
        }

        select {
            background-color: var(--dr-black);
            color: var(--dr-white);
            border: 1px solid var(--dr-white);
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            width: 100%;
        }

        select option.unused-item {
            color: var(--dr-light-grey);
            font-style: italic;
        }

        .stats-display {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            text-align: center;
            gap: 10px;
        }

        .stat {
            background-color: #222;
            padding: 10px 5px;
            border: 1px solid #555;
        }

        .stat .label {
            font-size: 0.8em;
            color: var(--dr-light-grey);
        }
        
        .stat .value {
            font-size: 1.2em;
        }

        .effects-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            background-color: #1a1a1a;
            border: 1px solid #555;
            min-height: 80px;
            padding: 10px;
        }

        .effects-list li {
            font-size: 0.8em;
            position: relative;
            padding-left: 20px;
        }

        .effects-list li::before {
           content: '*';
           position: absolute;
           left: 0;
           color: var(--dr-yellow);
       }

       /* New styles for the checklist and results */
       #item-selection {
           margin-bottom: 30px;
       }

       #item-selection h2, #results-container h2 {
           color: var(--dr-yellow);
           text-align: center;
           margin-bottom: 20px;
       }

       #weapon-checklist, #armor-checklist {
           display: flex;
           flex-direction: column;
           gap: 10px;
           margin-bottom: 20px;
       }

       .checklist-item {
           display: flex;
           align-items: center;
           gap: 10px;
           padding: 5px;
           border: 1px solid var(--dr-grey);
       }

       .checklist-item input[type="checkbox"] {
           transform: scale(1.5);
       }

       #calculate-button {
           display: block;
           margin: 20px auto;
           padding: 10px 20px;
           background-color: var(--dr-purple);
           color: var(--dr-white);
           border: none;
           font-family: 'Press Start 2P', cursive;
           font-size: 16px;
           cursor: pointer;
       }

       #calculate-button:hover {
           background-color: #a066cc; /* Slightly darker purple for hover */
       }

       #results-container {
           margin-top: 30px;
       }

       #results-container > div {
           background-color: var(--dr-grey);
           border: 2px solid var(--dr-white);
           padding: 15px;
           margin-bottom: 20px;
       }

       #results-container h3 {
           color: var(--dr-cyan); /* Default color, will be overridden for each character */
           margin-top: 0;
           border-bottom: 1px solid var(--dr-white);
           padding-bottom: 5px;
       }

       #susie-results h3 { color: var(--dr-purple); }
       #ralsei-results h3 { color: var(--dr-green); }
       #loadout-customization {
           background-color: var(--dr-grey);
           border: 2px solid var(--dr-white);
           padding: 15px;
           margin-bottom: 20px;
       }

       #loadout-customization h2 {
           color: var(--dr-yellow);
           text-align: center;
           margin-top: 0;
           margin-bottom: 15px;
           padding-bottom: 5px;
           border-bottom: 1px solid var(--dr-white);
       }

       #priority-presets {
           width: 100%;
           margin-bottom: 15px;
           background-color: var(--dr-black);
           color: var(--dr-white);
           border: 1px solid var(--dr-white);
           padding: 8px;
           font-family: 'Press Start 2P', cursive;
           font-size: 12px;
       }

       #loadout-customization div {
           margin-bottom: 10px;
       }

       #loadout-customization label {
           display: block;
           margin-bottom: 5px;
           color: var(--dr-cyan);
       }

       #loadout-customization input[type="range"] {
           width: 100%;
       }

       #reset-priorities {
           display: block;
           margin: 15px auto 0;
           padding: 8px 15px;
           background-color: var(--dr-purple);
           color: var(--dr-white);
           border: none;
           font-family: 'Press Start 2P', cursive;
           font-size: 12px;
           cursor: pointer;
       }

       #reset-priorities:hover {
           background-color: #a066cc;
       }

       #loadout-customization span {
           color: var(--dr-yellow);
       }
    </style>
</head>
<body>

    <div class="container">
        <h1>Deltarune Ultimate Loadout Calculator</h1>
        <p class="subtitle">Select equipment for each character to see their final stats and abilities.</p>

        <div id="party-selection">
            <h2>Select Your Party</h2>
            <div>
                <input type="checkbox" id="kris-party" name="kris-party" checked disabled>
                <label for="kris-party">Kris (Always in party)</label>
            </div>
            <div>
                <input type="checkbox" id="susie-party" name="susie-party">
                <label for="susie-party">Susie</label>
            </div>
            <div>
                <input type="checkbox" id="ralsei-party" name="ralsei-party">
                <label for="ralsei-party">Ralsei</label>
            </div>
            <div>
                <input type="checkbox" id="noelle-party" name="noelle-party">
                <label for="noelle-party">Noelle</label>
            </div>
        </div>

        <div id="item-selection">
            <h2>Your Collected Items</h2>
            <div id="weapon-checklist">
                <h3>Weapons</h3>
                <!-- Weapon checklist items will be populated here by JavaScript -->
            </div>
            <div id="armor-checklist">
                <h3>Armor</h3>
                <!-- Armor checklist items will be populated here by JavaScript -->
            </div>
            <div id="loadout-customization">
                <h2>Customize Your Loadout Priorities</h2>
                <select id="priority-presets" title="Loadout Priority Presets">
                    <option value="balanced">Balanced</option>
                    <option value="offensive">Offensive</option>
                    <option value="defensive">Defensive</option>
                    <option value="magic">Magic-focused</option>
                    <option value="custom">Custom</option>
                </select>
                <div>
                    <label for="priority-at">AT: <span id="priority-at-value">40</span>%</label>
                    <input type="range" id="priority-at" min="0" max="100" value="40">
                </div>
                <div>
                    <label for="priority-df">DF: <span id="priority-df-value">40</span>%</label>
                    <input type="range" id="priority-df" min="0" max="100" value="40">
                </div>
                <div>
                    <label for="priority-magic">Magic: <span id="priority-magic-value">20</span>%</label>
                    <input type="range" id="priority-magic" min="0" max="100" value="20">
                </div>
                <button id="reset-priorities">Reset to Default</button>
            </div>
            <button id="calculate-button">Calculate Optimal Loadouts</button>
            <div id="loading-indicator" style="display: none; text-align: center; margin-top: 10px;">
                <span style="color: var(--dr-yellow);">Calculating optimal loadouts...</span>
            </div>
        </div>

        <div id="results-container" style="display:none;">
            <h2>Optimal Loadouts</h2>
            <div id="kris-results">
                <h3>Kris</h3>
                <!-- Kris's results will be populated here -->
            </div>
            <div id="susie-results">
                <h3>Susie</h3>
                <!-- Susie's results will be populated here -->
            </div>
            <div id="ralsei-results">
                <h3>Ralsei</h3>
                <!-- Ralsei's results will be populated here -->
            </div>
            <div id="noelle-results">
                <h3>Noelle</h3>
                <!-- Noelle's results will be populated here -->
            </div>
        </div>
    </div>

    <script>
    const db = {
        characters: {
            kris: { name: 'Kris', base: { at: 10, df: 2, magic: 0 }, weaponType: 'Sword', usableStats: ['at', 'df'] },
            susie: { name: 'Susie', base: { at: 14, df: 2, magic: 0 }, weaponType: 'Axe', usableStats: ['at', 'df'] },
            ralsei: { name: 'Ralsei', base: { at: 10, df: 2, magic: 7 }, weaponType: 'Scarf', usableStats: ['at', 'df', 'magic'] },
            noelle: { name: 'Noelle', base: { at: 10, df: 1, magic: 2 }, weaponType: 'Ring', usableStats: ['at', 'df', 'magic'] }
        },
        equipment: [
            // --- WEAPONS ---
            // Swords (Kris)
            { name: "Wood Blade", type: "Weapon", weaponType: "Sword", stats: { at: 1 }, effects: [] },
            { name: "Spookysword", type: "Weapon", weaponType: "Sword", stats: { at: 2 }, effects: ["Spookiness UP"] },
            { name: "Mecha Saber", type: "Weapon", weaponType: "Sword", stats: { at: 4 }, effects: ["Annoying"] },
            { name: "Bounce Blade", type: "Weapon", weaponType: "Sword", stats: { at: 2, df: 1 }, effects: [] },
            { name: "Saber10", type: "Weapon", weaponType: "Sword", stats: { at: 6 }, effects: [] },
            { name: "Jingle Blade", type: "Weapon", weaponType: "Sword", stats: { at: 7, df: 1 }, effects: ["Festive"] },
            { name: "Winglade", type: "Weapon", weaponType: "Sword", stats: { at: 8 }, effects: ["$ +5%"] },
            { name: "Black Shard", type: "Weapon", weaponType: "Sword", stats: { at: 16 }, effects: ["Effective vs Dark"] },
            { name: "Trefoil", type: "Weapon", weaponType: "Sword", stats: { at: 4 }, effects: ["$ found +5%"], unused: true },
            { name: "Twisted Sword", type: "Weapon", weaponType: "Sword", stats: { at: 16 }, effects: ["Trance Down (Non-functional)"], unused: true },

            // Axes (Susie)
            { name: "Mane Ax", type: "Weapon", weaponType: "Axe", stats: { at: 0 }, effects: [] },
            { name: "Brave Ax", type: "Weapon", weaponType: "Axe", stats: { at: 2 }, effects: ["Guts UP"] },
            { name: "Auto Axe", type: "Weapon", weaponType: "Axe", stats: { at: 4 }, effects: ["BadIdea"] },
            { name: "Devilsknife", type: "Weapon", weaponType: "Axe", stats: { at: 5, magic: 4 }, effects: ["Buster TP DOWN (-10% cost)"] },
            { name: "Toxic Axe", type: "Weapon", weaponType: "Axe", stats: { at: 6 }, effects: [] },
            { name: "AbsorbAx", type: "Weapon", weaponType: "Axe", stats: { at: 8 }, effects: ["Vampire (HP steal)"] },
            { name: "Justice Axe", type: "Weapon", weaponType: "Axe", stats: { at: 12 }, effects: ["Attainment strength"] },

            // Scarves (Ralsei)
            { name: "Red Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 0 }, effects: [] },
            { name: "Ragger", type: "Weapon", weaponType: "Scarf", stats: { at: 2 }, effects: [] },
            { name: "Dainty Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 0, magic: 2 }, effects: ["Fluffiness UP"] },
            { name: "Fiber Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 2, magic: 2 }, effects: [] },
            { name: "Flex Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 4, magic: 1 }, effects: [] },
            { name: "Ragger2", type: "Weapon", weaponType: "Scarf", stats: { at: 5, magic: -1 }, effects: ["Prickly"] },
            { name: "Puppet Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 10, magic: -6 }, effects: ["For those that abandon healing"] },
            { name: "Cheer Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 1, magic: 2 }, effects: ["More TP from criticals"], unused: true },

            // Rings (Noelle)
            { name: "Snow Ring", type: "Weapon", weaponType: "Ring", stats: { at: 0, magic: 0 }, effects: [] },
            { name: "Freeze Ring", type: "Weapon", weaponType: "Ring", stats: { at: 4, magic: 4 }, effects: [] },
            { name: "Thorn Ring", type: "Weapon", weaponType: "Ring", stats: { at: 14, magic: 12 }, effects: ["Trance (HP drain)", "Ice Spell TP cost / 2"] },

            // --- ARMOR --- (Character: null means equippable by all, unless special cased)
            { name: "Bandage", type: "Armor", stats: { at: 0, df: 0 }, effects: [] },
            { name: "White Ribbon", type: "Armor", stats: { df: 2 }, effects: ["Cuteness"], restrictedTo: ["Kris", "Ralsei", "Noelle"] },
            { name: "Amber Card", type: "Armor", stats: { df: 1 }, effects: [] },
            { name: "Dice Brace", type: "Armor", stats: { df: 2 }, effects: [] },
            { name: "Iron Shackle", type: "Armor", stats: { at: 1, df: 2 }, effects: ["Ironically increases stats"] },
            { name: "Jevilstail", type: "Armor", stats: { at: 2, df: 2, magic: 2 }, effects: ["Devilenergy"] },
            { name: "Silver Card", type: "Armor", stats: { df: 2 }, effects: ["$ +5%"] },
            { name: "Glow Wrist", type: "Armor", stats: { df: 2 }, effects: [] },
            { name: "Silver Watch", type: "Armor", stats: { df: 2 }, effects: ["GrazeTime (Turn length -10%)"] },
            { name: "Royal Pin", type: "Armor", stats: { df: 3, magic: 1 }, effects: [] },
            { name: "Pink Ribbon", type: "Armor", stats: { df: 1 }, effects: ["GrazeArea +44%"] },
            { name: "Mannequin", type: "Armor", stats: { df: 0 }, effects: ["-35% damage from Puppet/Cat"] },
            { name: "B.ShotBowtie", type: "Armor", stats: { df: 2, magic: 1 }, effects: [] },
            { name: "Chain Mail", type: "Armor", stats: { df: 3 }, effects: [] },
            { name: "Frayed Bowtie", type: "Armor", stats: { at: 1, df: 1, magic: 1 }, effects: ["-15% damage from Puppet/Cat"] },
            { name: "Dealmaker", type: "Armor", stats: { df: 5, magic: 5 }, effects: ["$ +30%", "-40% damage from Puppet/Cat"] },
            { name: "Twin Ribbon", type: "Armor", stats: { df: 3 }, effects: ["GrazeArea +56.25%"] },
            { name: "Spike Band", type: "Armor", stats: { at: 2, df: 1 }, effects: [] },
            { name: "Tension Bow", type: "Armor", stats: { df: 2 }, effects: ["TPGain +10%"] },
            { name: "TennaTie", type: "Armor", stats: { df: 5, magic: -2 }, effects: [] },
            { name: "Shadow Mantle", type: "Armor", stats: { df: 1 }, effects: ["DF+1 per chapter", "-66% damage from Dark/Star"] },
            { name: "MysticBand", type: "Armor", stats: { magic: 4 }, effects: [] },
            { name: "PrincessRBN", type: "Armor", stats: { df: 4, at: 2 }, effects: ["Elegance UP"] },
            { name: "Waferguard", type: "Armor", stats: { df: 4 }, effects: [] },
            { name: "GoldWidow", type: "Armor", stats: { df: 5, at: 1, magic: 1 }, effects: ["$ -10%"] },
            { name: "Mouse Token", type: "Armor", stats: { df: 1, magic: 2 }, effects: [], unused: true },
            { name: "Sky Mantle", type: "Armor", stats: { df: 1 }, effects: ["-50% damage from Elec/Holy"], unused: true },
            { name: "Spike Shackle", type: "Armor", stats: { at: 3, df: 1 }, effects: [], unused: true },
        ]
    };

    // Priority data management
    let currentPriorities = { at: 40, df: 40, magic: 20 }; // Initialize with "Balanced" preset

    const priorityPresets = {
        'balanced': { at: 40, df: 40, magic: 20 },
        'offensive': { at: 70, df: 20, magic: 10 },
        'defensive': { at: 20, df: 70, magic: 10 },
        'magic': { at: 10, df: 20, magic: 70 },
        'custom': { at: 0, df: 0, magic: 0 } // Default custom values
    };

    // Function to normalize priorities so they sum to 1
    function normalizePriorities(rawPriorities) {
        const total = rawPriorities.at + rawPriorities.df + rawPriorities.magic;
        if (total === 0) {
            // If all priorities are 0, return equal weights
            return { at: 1/3, df: 1/3, magic: 1/3 };
        }
        return {
            at: rawPriorities.at / total,
            df: rawPriorities.df / total,
            magic: rawPriorities.magic / total
        };
    }
    
    // Function to calculate the score of a loadout based on priorities
    function calculateLoadoutScore(loadout, priorities, character) {
        // Only consider stats that the character can use
        let score = 0;
        for (const stat of character.usableStats) {
            score += loadout.totalStats[stat] * priorities[stat];
        }
        return score;
    }
    
    // Function to populate the weapon and armor checklists
    function populateChecklists() {
        const weaponChecklist = document.getElementById('weapon-checklist');
        const armorChecklist = document.getElementById('armor-checklist');
        
        // Clear existing content except the headers
        weaponChecklist.innerHTML = '<h3>Weapons</h3>';
        armorChecklist.innerHTML = '<h3>Armor</h3>';
        
        // Iterate through equipment and create checklist items
        db.equipment.forEach((item, index) => {
            // Create container div for the checkbox, label, and quantity input
            const container = document.createElement('div');
            container.className = 'checklist-item';
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `item-${index}`;
            checkbox.value = item.name;
            checkbox.name = item.name;
            
            // Add data attributes for item properties
            checkbox.dataset.at = item.stats.at || 0;
            checkbox.dataset.df = item.stats.df || 0;
            checkbox.dataset.magic = item.stats.magic || 0;
            checkbox.dataset.type = item.type;
            if (item.weaponType) {
                checkbox.dataset.weaponType = item.weaponType;
            }
            if (item.restrictedTo) {
                checkbox.dataset.restrictedTo = JSON.stringify(item.restrictedTo);
            }
            if (item.unused) {
                checkbox.dataset.unused = true;
            }
            
            // Create label
            const label = document.createElement('label');
            label.htmlFor = `item-${index}`;
            label.textContent = item.name;
            
            // Create quantity input
            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = '1';
            quantityInput.value = '1';
            quantityInput.style.display = 'none';
            quantityInput.className = 'quantity-input';
            quantityInput.id = `quantity-${index}`;
            
            // Add event listener to show/hide quantity input (without saving state)
            checkbox.addEventListener('change', function() {
                if (this.checked) {
                    quantityInput.style.display = 'inline-block';
                } else {
                    quantityInput.style.display = 'none';
                    quantityInput.value = '1'; // Reset to 1 when unchecked
                }
                saveStateToLocalStorage(); // Save state when checkbox is toggled
            });
            
            // Add elements to container
            container.appendChild(checkbox);
            container.appendChild(label);
            container.appendChild(quantityInput);
            
            // Add to appropriate checklist
            if (item.type === 'Weapon') {
                weaponChecklist.appendChild(container);
            } else if (item.type === 'Armor') {
                armorChecklist.appendChild(container);
            }
        });
    }
    
    // Function to save the current state to localStorage
    function saveStateToLocalStorage() {
        const state = {
            party: {},
            items: {},
            priorities: currentPriorities
        };
        
        // Save party member checkbox states
        const partyCheckboxes = document.querySelectorAll('#party-selection input[type="checkbox"]');
        partyCheckboxes.forEach(checkbox => {
            state.party[checkbox.id] = checkbox.checked;
        });
        
        // Save item checkbox states and quantities
        const itemCheckboxes = document.querySelectorAll('#item-selection input[type="checkbox"]');
        itemCheckboxes.forEach(checkbox => {
            const index = checkbox.id.split('-')[1];
            state.items[checkbox.id] = {
                checked: checkbox.checked,
                quantity: document.getElementById(`quantity-${index}`)?.value || '1'
            };
        });
        
        localStorage.setItem('deltaruneLoadoutCalculatorState', JSON.stringify(state));
    }
    
    // Function to load the state from localStorage
    function loadStateFromLocalStorage() {
        const savedState = localStorage.getItem('deltaruneLoadoutCalculatorState');
        if (!savedState) return;
        
        const state = JSON.parse(savedState);
        
        // Load party member checkbox states
        for (const [id, checked] of Object.entries(state.party)) {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = checked;
            }
        }
        
        // Load item checkbox states and quantities
        for (const [id, itemState] of Object.entries(state.items)) {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = itemState.checked;
                
                // Get the index to find the corresponding quantity input
                const index = id.split('-')[1];
                const quantityInput = document.getElementById(`quantity-${index}`);
                
                if (quantityInput) {
                    quantityInput.value = itemState.quantity;
                    
                    // Show quantity input if checkbox is checked
                    if (itemState.checked) {
                        quantityInput.style.display = 'inline-block';
                    }
                }
            }
        }
        
        // Load priority data if available
        if (state.priorities) {
            currentPriorities = {...state.priorities};
            updatePriorityUI();
        }
    }
    
    // Call populateChecklists when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        populateChecklists();
        
        // Load saved state from localStorage
        loadStateFromLocalStorage();
        
        // Add event listeners to party member checkboxes
        const partyCheckboxes = document.querySelectorAll('#party-selection input[type="checkbox"]');
        partyCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                saveStateToLocalStorage(); // Save state when party checkbox changes
            });
        });
        
        // Add event listener to the calculate button
        document.getElementById('calculate-button').addEventListener('click', handleCalculation);
        
        // Add event listeners to all item quantity inputs
        const quantityInputs = document.querySelectorAll('.quantity-input');
        quantityInputs.forEach(input => {
            input.addEventListener('change', function() {
                saveStateToLocalStorage(); // Save state when quantity changes
            });
        });
        
        // Add event listeners for loadout customization
        setupPriorityEventListeners();
        
        // Initialize the UI with the current priorities
        updatePriorityUI();
    });

    // Function to set up event listeners for priority controls
    function setupPriorityEventListeners() {
        // Event listener for priority presets dropdown
        document.getElementById('priority-presets').addEventListener('change', function() {
            const selectedPreset = this.value;
            const presetName = this.options[this.selectedIndex].text;
            
            if (priorityPresets[presetName]) {
                currentPriorities = {...priorityPresets[presetName]};
                updatePriorityUI();
                saveStateToLocalStorage();
            }
        });
        
        // Event listeners for sliders
        document.getElementById('priority-at').addEventListener('input', function() {
            currentPriorities.at = parseInt(this.value);
            updatePriorityDisplay();
            setPresetToCustom();
            saveStateToLocalStorage();
        });
        
        document.getElementById('priority-df').addEventListener('input', function() {
            currentPriorities.df = parseInt(this.value);
            updatePriorityDisplay();
            setPresetToCustom();
            saveStateToLocalStorage();
        });
        
        document.getElementById('priority-magic').addEventListener('input', function() {
            currentPriorities.magic = parseInt(this.value);
            updatePriorityDisplay();
            setPresetToCustom();
            saveStateToLocalStorage();
        });
        
        // Event listener for reset button
        document.getElementById('reset-priorities').addEventListener('click', function() {
            currentPriorities = {...priorityPresets['Balanced']};
            updatePriorityUI();
            saveStateToLocalStorage();
        });
    }
    
    // Function to update the priority display values
    function updatePriorityDisplay() {
        document.getElementById('priority-at-value').textContent = currentPriorities.at;
        document.getElementById('priority-df-value').textContent = currentPriorities.df;
        document.getElementById('priority-magic-value').textContent = currentPriorities.magic;
    }
    
    // Function to update all priority UI elements
    function updatePriorityUI() {
        // Update slider positions
        document.getElementById('priority-at').value = currentPriorities.at;
        document.getElementById('priority-df').value = currentPriorities.df;
        document.getElementById('priority-magic').value = currentPriorities.magic;
        
        // Update display values
        updatePriorityDisplay();
        
        // Update preset dropdown to match current priorities if they match a preset
        updatePresetDropdown();
    }
    
    // Function to set the preset dropdown to "Custom"
    function setPresetToCustom() {
        const presetDropdown = document.getElementById('priority-presets');
        for (let i = 0; i < presetDropdown.options.length; i++) {
            if (presetDropdown.options[i].value === 'custom') {
                presetDropdown.selectedIndex = i;
                break;
            }
        }
    }
    
    // Function to update the preset dropdown to match current priorities if they match a preset
    function updatePresetDropdown() {
        const presetDropdown = document.getElementById('priority-presets');
        let foundMatch = false;
        
        for (const [presetName, presetValues] of Object.entries(priorityPresets)) {
            if (currentPriorities.at === presetValues.at &&
                currentPriorities.df === presetValues.df &&
                currentPriorities.magic === presetValues.magic) {
                for (let i = 0; i < presetDropdown.options.length; i++) {
                    if (presetDropdown.options[i].value === presetName) {
                        presetDropdown.selectedIndex = i;
                        foundMatch = true;
                        break;
                    }
                }
                break;
            }
        }
        
        // If no match found, set to Custom
        if (!foundMatch) {
            setPresetToCustom();
        }
    }

    // Function to handle the calculation process
    function handleCalculation() {
        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        loadingIndicator.style.display = 'block';
        
        // Gather all checked items and create a pool based on quantities
        const checkedItems = document.querySelectorAll('#item-selection input[type="checkbox"]:checked');
        const availableItems = [];
        
        checkedItems.forEach(checkbox => {
            // Get the index from the checkbox ID to find the corresponding quantity input
            const index = checkbox.id.split('-')[1];
            const quantityInput = document.getElementById(`quantity-${index}`);
            const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
            
            // Create item object
            const item = {
                name: checkbox.value,
                type: checkbox.dataset.type,
                weaponType: checkbox.dataset.weaponType,
                at: parseInt(checkbox.dataset.at) || 0,
                df: parseInt(checkbox.dataset.df) || 0,
                magic: parseInt(checkbox.dataset.magic) || 0,
                restrictedTo: checkbox.dataset.restrictedTo ? JSON.parse(checkbox.dataset.restrictedTo) : null,
                unused: checkbox.dataset.unused === 'true'
            };
            
            // Add multiple instances of the item to the pool based on quantity
            for (let i = 0; i < quantity; i++) {
                availableItems.push({...item}); // Use spread to create a copy
            }
        });
        
        // Get current priorities
        const rawPriorities = {...currentPriorities};
        
        // Normalize the priorities
        const normalizedPriorities = normalizePriorities(rawPriorities);
        
        // Identify selected party members
        const selectedParty = [];
        if (document.getElementById('kris-party').checked) selectedParty.push('kris');
        if (document.getElementById('susie-party').checked) selectedParty.push('susie');
        if (document.getElementById('ralsei-party').checked) selectedParty.push('ralsei');
        if (document.getElementById('noelle-party').checked) selectedParty.push('noelle');
        
        // Use setTimeout to make the calculation non-blocking
        setTimeout(() => {
            // Calculate optimal loadouts only for selected party members using the new algorithm
            const loadouts = calculateOptimalLoadoutsWithPriorities(availableItems, normalizedPriorities, selectedParty);
            
            // Display results
            displayResults(loadouts, selectedParty);
            
            // Hide loading indicator
            loadingIndicator.style.display = 'none';
        }, 0);
    }
    
    // Function to calculate optimal loadouts for all characters with priorities
    function calculateOptimalLoadoutsWithPriorities(availableItems, priorities, partyMembers) {
        // Create a working copy of the available items
        let currentPool = [...availableItems];
        const loadouts = {};
    
        // Only calculate loadouts for selected party members
        for (const charKey of partyMembers) {
            const character = db.characters[charKey];
            
            // Find all valid weapons for this character from the current pool
            const validWeapons = currentPool.filter(item =>
                item.type === 'Weapon' &&
                item.weaponType === character.weaponType &&
                (!item.restrictedTo || item.restrictedTo.includes(character.name))
            );
            
            // Find all valid armors for this character from the current pool
            const validArmors = currentPool.filter(item =>
                item.type === 'Armor' &&
                (!item.restrictedTo || item.restrictedTo.includes(character.name))
            );
            
            let bestLoadout = null;
            let bestScore = -1;
            
            // Try all combinations of weapons and 2 armors
            for (const weapon of validWeapons) {
                // Create a set of used items for this iteration
                const usedItems = new Set([weapon]);
                
                // Try all combinations of 2 armors
                for (let i = 0; i < validArmors.length; i++) {
                    const armor1 = validArmors[i];
                    // Skip if this armor is the same as the weapon or already used
                    if (usedItems.has(armor1)) continue;
                    
                    // Add the first armor to used items for this iteration
                    usedItems.add(armor1);
                    
                    for (let j = i + 1; j < validArmors.length; j++) {
                        const armor2 = validArmors[j];
                        // Skip if this armor is the same as the weapon or the first armor or already used
                        if (usedItems.has(armor2)) continue;
                        
                        // Create a potential loadout
                        const loadout = {
                            weapon: weapon,
                            armor1: armor1,
                            armor2: armor2,
                            totalStats: {
                                at: character.base.at + weapon.at + armor1.at + armor2.at,
                                df: character.base.df + weapon.df + armor1.df + armor2.df,
                                magic: character.base.magic + weapon.magic + armor1.magic + armor2.magic
                            }
                        };
                        
                        // Calculate the score for this loadout
                        const score = calculateLoadoutScore(loadout, priorities, character);
                        
                        // Update best loadout if this one is better
                        if (score > bestScore) {
                            bestScore = score;
                            bestLoadout = loadout;
                        }
                    }
                    
                    // Remove the first armor from used items for next iteration
                    usedItems.delete(armor1);
                }
            }
            
            // If no valid loadout was found, create an empty one
            if (!bestLoadout) {
                bestLoadout = {
                    weapon: null,
                    armor1: null,
                    armor2: null,
                    totalStats: {
                        at: character.base.at,
                        df: character.base.df,
                        magic: character.base.magic
                    }
                };
            } else {
                // Remove the assigned items from the current pool
                if (bestLoadout.weapon) {
                    const weaponIndex = currentPool.indexOf(bestLoadout.weapon);
                    if (weaponIndex !== -1) currentPool.splice(weaponIndex, 1);
                }
                if (bestLoadout.armor1) {
                    const armor1Index = currentPool.indexOf(bestLoadout.armor1);
                    if (armor1Index !== -1) currentPool.splice(armor1Index, 1);
                }
                if (bestLoadout.armor2) {
                    const armor2Index = currentPool.indexOf(bestLoadout.armor2);
                    if (armor2Index !== -1) currentPool.splice(armor2Index, 1);
                }
            }
            
            loadouts[charKey] = bestLoadout;
        }
    
        return loadouts;
    }
    
    // Function to display the calculated results
    function displayResults(loadouts, selectedParty) {
        // Define all character keys
        const allCharacters = ['kris', 'susie', 'ralsei', 'noelle'];
        
        // Iterate through all characters
        for (const charKey of allCharacters) {
            const resultsContainer = document.getElementById(`${charKey}-results`);
            
            // Check if character is in the selected party
            if (selectedParty.includes(charKey)) {
                // Character is in party, display their loadout
                const loadout = loadouts[charKey];
                
                // Clear existing content
                resultsContainer.innerHTML = `<h3>${db.characters[charKey].name}</h3>`;
                
                // Create and populate results content
                const weaponName = loadout.weapon ? loadout.weapon.name : 'None';
                const armor1Name = loadout.armor1 ? loadout.armor1.name : 'None';
                const armor2Name = loadout.armor2 ? loadout.armor2.name : 'None';
                
                const statsHTML = `
                    <p><strong>Weapon:</strong> ${weaponName}</p>
                    <p><strong>Armor 1:</strong> ${armor1Name}</p>
                    <p><strong>Armor 2:</strong> ${armor2Name}</p>
                    <div class="stats-display">
                        <div class="stat">
                            <div class="label">AT</div>
                            <div class="value">${loadout.totalStats.at}</div>
                        </div>
                        <div class="stat">
                            <div class="label">DF</div>
                            <div class="value">${loadout.totalStats.df}</div>
                        </div>
                        <div class="stat">
                            <div class="label">MG</div>
                            <div class="value">${loadout.totalStats.magic}</div>
                        </div>
                    </div>
                `;
                
                resultsContainer.innerHTML += statsHTML;
                resultsContainer.style.display = 'block'; // Show the container
            } else {
                // Character is not in party, hide their results
                resultsContainer.style.display = 'none';
            }
        }
        
        // Show the results container
        document.getElementById('results-container').style.display = 'block';
    }
</script>
</body>
</html>