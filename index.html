<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deltarune Ultimate Loadout Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --dr-black: #000000;
            --dr-white: #FFFFFF;
            --dr-cyan: #00FFFF;
            --dr-pink: #FF9CF6;
            --dr-green: #37FF52;
            --dr-purple: #C27EFF;
            --dr-yellow: #FFFF00;
            --dr-grey: #444444;
            --dr-light-grey: #999999;
        }

        body {
            background-color: var(--dr-black);
            color: var(--dr-white);
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            -webkit-font-smoothing: none;
            image-rendering: pixelated;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: var(--dr-yellow);
            text-align: center;
            text-shadow: 2px 2px var(--dr-purple);
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: var(--dr-light-grey);
            font-size: 0.8em;
            margin-bottom: 40px;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .character-card {
            background-color: var(--dr-grey);
            border: 2px solid var(--dr-white);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .character-card h2 {
            margin: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--dr-white);
            text-align: center;
        }
        #kris-header { color: var(--dr-cyan); }
        #susie-header { color: var(--dr-purple); }
        #ralsei-header { color: var(--dr-green); }
        #noelle-header { color: var(--dr-pink); }
        
        .equip-group, .stats-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            color: var(--dr-yellow);
        }

        select {
            background-color: var(--dr-black);
            color: var(--dr-white);
            border: 1px solid var(--dr-white);
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            width: 100%;
        }

        select option.unused-item {
            color: var(--dr-light-grey);
            font-style: italic;
        }

        .stats-display {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            text-align: center;
            gap: 10px;
        }

        .stat {
            background-color: #222;
            padding: 10px 5px;
            border: 1px solid #555;
        }

        .stat .label {
            font-size: 0.8em;
            color: var(--dr-light-grey);
        }
        
        .stat .value {
            font-size: 1.2em;
        }

        .effects-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            background-color: #1a1a1a;
            border: 1px solid #555;
            min-height: 80px;
            padding: 10px;
        }

        .effects-list li {
            font-size: 0.8em;
            position: relative;
            padding-left: 20px;
        }

        .effects-list li::before {
           content: '*';
           position: absolute;
           left: 0;
           color: var(--dr-yellow);
       }

       /* New styles for the checklist and results */
       #item-selection {
           margin-bottom: 30px;
       }

       #item-selection h2, #results-container h2 {
           color: var(--dr-yellow);
           text-align: center;
           margin-bottom: 20px;
       }

       #weapon-checklist, #armor-checklist {
           display: flex;
           flex-direction: column;
           gap: 10px;
           margin-bottom: 20px;
       }

       .checklist-item {
           display: flex;
           align-items: center;
           gap: 10px;
           padding: 5px;
           border: 1px solid var(--dr-grey);
       }

       .checklist-item input[type="checkbox"] {
           transform: scale(1.5);
       }

       #calculate-button {
           display: block;
           margin: 20px auto;
           padding: 10px 20px;
           background-color: var(--dr-purple);
           color: var(--dr-white);
           border: none;
           font-family: 'Press Start 2P', cursive;
           font-size: 16px;
           cursor: pointer;
       }

       #calculate-button:hover {
           background-color: #a066cc; /* Slightly darker purple for hover */
       }

       #results-container {
           margin-top: 30px;
       }

       #results-container > div {
           background-color: var(--dr-grey);
           border: 2px solid var(--dr-white);
           padding: 15px;
           margin-bottom: 20px;
       }

       #results-container h3 {
           color: var(--dr-cyan); /* Default color, will be overridden for each character */
           margin-top: 0;
           border-bottom: 1px solid var(--dr-white);
           padding-bottom: 5px;
       }

       #susie-results h3 { color: var(--dr-purple); }
       #ralsei-results h3 { color: var(--dr-green); }

       #character-priority-section {
           background-color: var(--dr-grey);
           border: 2px solid var(--dr-white);
           padding: 15px;
           margin-bottom: 20px;
       }

       #character-priority-section h2 {
           color: var(--dr-yellow);
           text-align: center;
           margin-top: 0;
           margin-bottom: 15px;
           padding-bottom: 5px;
           border-bottom: 1px solid var(--dr-white);
       }

       #character-select {
           width: 100%;
           margin-bottom: 15px;
           background-color: var(--dr-black);
           color: var(--dr-white);
           border: 1px solid var(--dr-white);
           padding: 8px;
           font-family: 'Press Start 2P', cursive;
           font-size: 12px;
       }

       #priority-controls-container > div {
           background-color: var(--dr-black);
           border: 1px solid var(--dr-white);
           padding: 10px;
           margin-bottom: 15px;
       }

       #priority-controls-container select {
           width: 100%;
           margin-bottom: 15px;
           background-color: var(--dr-black);
           color: var(--dr-white);
           border: 1px solid var(--dr-white);
           padding: 8px;
           font-family: 'Press Start 2P', cursive;
           font-size: 12px;
       }

       #priority-controls-container div {
           margin-bottom: 10px;
       }

       #priority-controls-container label {
           display: block;
           margin-bottom: 5px;
           color: var(--dr-cyan);
       }

       #priority-controls-container input[type="range"] {
           width: 100%;
       }

       #priority-controls-container button {
           display: block;
           margin: 15px auto 0;
           padding: 8px 15px;
           background-color: var(--dr-purple);
           color: var(--dr-white);
           border: none;
           font-family: 'Press Start 2P', cursive;
           font-size: 12px;
           cursor: pointer;
       }

       #priority-controls-container button:hover {
           background-color: #a066cc;
       }

       #priority-controls-container span {
           color: var(--dr-yellow);
       }
    </style>
</head>
<body>

    <div class="container">
        <h1>Deltarune Ultimate Loadout Calculator</h1>
        <p class="subtitle">Select equipment for each character to see their final stats and abilities.</p>

        <div id="party-selection">
            <h2>Select Your Party</h2>
            <div>
                <input type="checkbox" id="kris-party" name="kris-party" checked disabled>
                <label for="kris-party">Kris (Always in party)</label>
            </div>
            <div>
                <input type="checkbox" id="susie-party" name="susie-party">
                <label for="susie-party">Susie</label>
            </div>
            <div>
                <input type="checkbox" id="ralsei-party" name="ralsei-party">
                <label for="ralsei-party">Ralsei</label>
            </div>
            <div>
                <input type="checkbox" id="noelle-party" name="noelle-party">
                <label for="noelle-party">Noelle</label>
            </div>
        </div>

        <div id="character-priority-section">
            <h2>Set Individual Character Priorities</h2>
            <select id="character-select" title="Select Character">
                <option value="kris">Kris</option>
                <option value="susie">Susie</option>
                <option value="ralsei">Ralsei</option>
                <option value="noelle">Noelle</option>
            </select>
            <div id="priority-controls-container">
                <!-- Dynamic priority controls will be inserted here by JavaScript -->
            </div>
        </div>

        <div id="priority-controls-template" style="display: none;">
            <select class="priority-presets" title="Loadout Priority Presets">
                <option value="balanced">Balanced</option>
                <option value="offensive">Offensive</option>
                <option value="defensive">Defensive</option>
                <option value="magic">Magic-focused</option>
                <option value="custom">Custom</option>
            </select>
            <div>
                <label for="priority-at">AT: <span class="priority-at-value">40</span>%</label>
                <input type="range" class="priority-at" min="0" max="100" value="40">
            </div>
            <div>
                <label for="priority-df">DF: <span class="priority-df-value">40</span>%</label>
                <input type="range" class="priority-df" min="0" max="100" value="40">
            </div>
            <div>
                <label for="priority-magic">Magic: <span class="priority-magic-value">20</span>%</label>
                <input type="range" class="priority-magic" min="0" max="100" value="20">
            </div>
            <button class="reset-priorities">Reset to Default</button>
        </div>

        <div id="item-selection">
            <h2>Your Collected Items</h2>
            <div id="weapon-checklist">
                <h3>Weapons</h3>
                <!-- Weapon checklist items will be populated here by JavaScript -->
            </div>
            <div id="armor-checklist">
                <h3>Armor</h3>
                <!-- Armor checklist items will be populated here by JavaScript -->
            </div>
            <button id="calculate-button">Calculate Optimal Loadouts</button>
            <div id="loading-indicator" style="display: none; text-align: center; margin-top: 10px;">
                <span style="color: var(--dr-yellow);">Calculating optimal loadouts...</span>
            </div>
        </div>

        <div id="results-container" style="display:none;">
            <h2>Optimal Loadouts</h2>
            <div id="kris-results">
                <h3>Kris</h3>
                <!-- Kris's results will be populated here -->
            </div>
            <div id="susie-results">
                <h3>Susie</h3>
                <!-- Susie's results will be populated here -->
            </div>
            <div id="ralsei-results">
                <h3>Ralsei</h3>
                <!-- Ralsei's results will be populated here -->
            </div>
            <div id="noelle-results">
                <h3>Noelle</h3>
                <!-- Noelle's results will be populated here -->
            </div>
        </div>
    </div>

    <script>
    const db = {
        characters: {
            kris: { name: 'Kris', base: { at: 10, df: 2, magic: 0 }, weaponType: 'Sword', usableStats: ['at', 'df'] },
            susie: { name: 'Susie', base: { at: 14, df: 2, magic: 0 }, weaponType: 'Axe', usableStats: ['at', 'df'] },
            ralsei: { name: 'Ralsei', base: { at: 10, df: 2, magic: 7 }, weaponType: 'Scarf', usableStats: ['at', 'df', 'magic'] },
            noelle: { name: 'Noelle', base: { at: 10, df: 1, magic: 2 }, weaponType: 'Ring', usableStats: ['at', 'df', 'magic'] }
        },
        equipment: [
            // --- WEAPONS ---
            // Swords (Kris)
            { name: "Wood Blade", type: "Weapon", weaponType: "Sword", stats: { at: 1 }, effects: [] },
            { name: "Spookysword", type: "Weapon", weaponType: "Sword", stats: { at: 2 }, effects: ["Spookiness UP"] },
            { name: "Mecha Saber", type: "Weapon", weaponType: "Sword", stats: { at: 4 }, effects: ["Annoying"] },
            { name: "Bounce Blade", type: "Weapon", weaponType: "Sword", stats: { at: 2, df: 1 }, effects: [] },
            { name: "Saber10", type: "Weapon", weaponType: "Sword", stats: { at: 6 }, effects: [] },
            { name: "Jingle Blade", type: "Weapon", weaponType: "Sword", stats: { at: 7, df: 1 }, effects: ["Festive"] },
            { name: "Winglade", type: "Weapon", weaponType: "Sword", stats: { at: 8 }, effects: ["$ +5%"] },
            { name: "Black Shard", type: "Weapon", weaponType: "Sword", stats: { at: 16 }, effects: ["Effective vs Dark"] },
            { name: "Trefoil", type: "Weapon", weaponType: "Sword", stats: { at: 4 }, effects: ["$ found +5%"], unused: true },
            { name: "Twisted Sword", type: "Weapon", weaponType: "Sword", stats: { at: 16 }, effects: ["Trance Down (Non-functional)"], unused: true },

            // Axes (Susie)
            { name: "Mane Ax", type: "Weapon", weaponType: "Axe", stats: { at: 0 }, effects: [] },
            { name: "Brave Ax", type: "Weapon", weaponType: "Axe", stats: { at: 2 }, effects: ["Guts UP"] },
            { name: "Auto Axe", type: "Weapon", weaponType: "Axe", stats: { at: 4 }, effects: ["BadIdea"] },
            { name: "Devilsknife", type: "Weapon", weaponType: "Axe", stats: { at: 5, magic: 4 }, effects: ["Buster TP DOWN (-10% cost)"] },
            { name: "Toxic Axe", type: "Weapon", weaponType: "Axe", stats: { at: 6 }, effects: [] },
            { name: "AbsorbAx", type: "Weapon", weaponType: "Axe", stats: { at: 8 }, effects: ["Vampire (HP steal)"] },
            { name: "Justice Axe", type: "Weapon", weaponType: "Axe", stats: { at: 12 }, effects: ["Attainment strength"] },

            // Scarves (Ralsei)
            { name: "Red Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 0 }, effects: [] },
            { name: "Ragger", type: "Weapon", weaponType: "Scarf", stats: { at: 2 }, effects: [] },
            { name: "Dainty Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 0, magic: 2 }, effects: ["Fluffiness UP"] },
            { name: "Fiber Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 2, magic: 2 }, effects: [] },
            { name: "Flex Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 4, magic: 1 }, effects: [] },
            { name: "Ragger2", type: "Weapon", weaponType: "Scarf", stats: { at: 5, magic: -1 }, effects: ["Prickly"] },
            { name: "Puppet Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 10, magic: -6 }, effects: ["For those that abandon healing"] },
            { name: "Cheer Scarf", type: "Weapon", weaponType: "Scarf", stats: { at: 1, magic: 2 }, effects: ["More TP from criticals"], unused: true },

            // Rings (Noelle)
            { name: "Snow Ring", type: "Weapon", weaponType: "Ring", stats: { at: 0, magic: 0 }, effects: [] },
            { name: "Freeze Ring", type: "Weapon", weaponType: "Ring", stats: { at: 4, magic: 4 }, effects: [] },
            { name: "Thorn Ring", type: "Weapon", weaponType: "Ring", stats: { at: 14, magic: 12 }, effects: ["Trance (HP drain)", "Ice Spell TP cost / 2"] },

            // --- ARMOR --- (Character: null means equippable by all, unless special cased)
            { name: "Bandage", type: "Armor", stats: { at: 0, df: 0 }, effects: [] },
            { name: "White Ribbon", type: "Armor", stats: { df: 2 }, effects: ["Cuteness"], restrictedTo: ["Kris", "Ralsei", "Noelle"] },
            { name: "Amber Card", type: "Armor", stats: { df: 1 }, effects: [] },
            { name: "Dice Brace", type: "Armor", stats: { df: 2 }, effects: [] },
            { name: "Iron Shackle", type: "Armor", stats: { at: 1, df: 2 }, effects: ["Ironically increases stats"] },
            { name: "Jevilstail", type: "Armor", stats: { at: 2, df: 2, magic: 2 }, effects: ["Devilenergy"] },
            { name: "Silver Card", type: "Armor", stats: { df: 2 }, effects: ["$ +5%"] },
            { name: "Glow Wrist", type: "Armor", stats: { df: 2 }, effects: [] },
            { name: "Silver Watch", type: "Armor", stats: { df: 2 }, effects: ["GrazeTime (Turn length -10%)"] },
            { name: "Royal Pin", type: "Armor", stats: { df: 3, magic: 1 }, effects: [] },
            { name: "Pink Ribbon", type: "Armor", stats: { df: 1 }, effects: ["GrazeArea +44%"] },
            { name: "Mannequin", type: "Armor", stats: { df: 0 }, effects: ["-35% damage from Puppet/Cat"] },
            { name: "B.ShotBowtie", type: "Armor", stats: { df: 2, magic: 1 }, effects: [] },
            { name: "Chain Mail", type: "Armor", stats: { df: 3 }, effects: [] },
            { name: "Frayed Bowtie", type: "Armor", stats: { at: 1, df: 1, magic: 1 }, effects: ["-15% damage from Puppet/Cat"] },
            { name: "Dealmaker", type: "Armor", stats: { df: 5, magic: 5 }, effects: ["$ +30%", "-40% damage from Puppet/Cat"] },
            { name: "Twin Ribbon", type: "Armor", stats: { df: 3 }, effects: ["GrazeArea +56.25%"] },
            { name: "Spike Band", type: "Armor", stats: { at: 2, df: 1 }, effects: [] },
            { name: "Tension Bow", type: "Armor", stats: { df: 2 }, effects: ["TPGain +10%"] },
            { name: "TennaTie", type: "Armor", stats: { df: 5, magic: -2 }, effects: [] },
            { name: "Shadow Mantle", type: "Armor", stats: { df: 1 }, effects: ["DF+1 per chapter", "-66% damage from Dark/Star"] },
            { name: "MysticBand", type: "Armor", stats: { magic: 4 }, effects: [] },
            { name: "PrincessRBN", type: "Armor", stats: { df: 4, at: 2 }, effects: ["Elegance UP"] },
            { name: "Waferguard", type: "Armor", stats: { df: 4 }, effects: [] },
            { name: "GoldWidow", type: "Armor", stats: { df: 5, at: 1, magic: 1 }, effects: ["$ -10%"] },
            { name: "Mouse Token", type: "Armor", stats: { df: 1, magic: 2 }, effects: [], unused: true },
            { name: "Sky Mantle", type: "Armor", stats: { df: 1 }, effects: ["-50% damage from Elec/Holy"], unused: true },
            { name: "Spike Shackle", type: "Armor", stats: { at: 3, df: 1 }, effects: [], unused: true },
        ]
    };

    // Priority data management
    const characterPriorities = {
        kris: { at: 40, df: 40, magic: 20 },
        susie: { at: 40, df: 40, magic: 20 },
        ralsei: { at: 40, df: 40, magic: 20 },
        noelle: { at: 40, df: 40, magic: 20 }
    };

    const priorityPresets = {
        'balanced': {
            kris: { at: 40, df: 40, magic: 20 },
            susie: { at: 40, df: 40, magic: 20 },
            ralsei: { at: 40, df: 40, magic: 20 },
            noelle: { at: 40, df: 40, magic: 20 }
        },
        'offensive': {
            kris: { at: 70, df: 20, magic: 10 },
            susie: { at: 70, df: 20, magic: 10 },
            ralsei: { at: 70, df: 20, magic: 10 },
            noelle: { at: 70, df: 20, magic: 10 }
        },
        'defensive': {
            kris: { at: 20, df: 70, magic: 10 },
            susie: { at: 20, df: 70, magic: 10 },
            ralsei: { at: 20, df: 70, magic: 10 },
            noelle: { at: 20, df: 70, magic: 10 }
        },
        'magic': {
            kris: { at: 10, df: 20, magic: 70 },
            susie: { at: 10, df: 20, magic: 70 },
            ralsei: { at: 10, df: 20, magic: 70 },
            noelle: { at: 10, df: 20, magic: 70 }
        },
        'custom': {
            kris: { at: 0, df: 0, magic: 0 },
            susie: { at: 0, df: 0, magic: 0 },
            ralsei: { at: 0, df: 0, magic: 0 },
            noelle: { at: 0, df: 0, magic: 0 }
        }
    };

    // Function to normalize priorities so they sum to 1
    function normalizePriorities(rawPriorities) {
        const total = rawPriorities.at + rawPriorities.df + rawPriorities.magic;
        if (total === 0) {
            // If all priorities are 0, return equal weights
            return { at: 1/3, df: 1/3, magic: 1/3 };
        }
        return {
            at: rawPriorities.at / total,
            df: rawPriorities.df / total,
            magic: rawPriorities.magic / total
        };
    }
    
    // Function to calculate the score of a loadout based on priorities
    function calculateLoadoutScore(loadout, priorities, character) {
        // Only consider stats that the character can use
        let score = 0;
        for (const stat of character.usableStats) {
            score += loadout.totalStats[stat] * priorities[stat];
        }
        return score;
    }
    
    // Helper function to find the best item for a specific slot
    function findBestItemForSlot(availableItems, slotType, character, priorities) {
        // Filter items based on slot type
        let validItems = [];
        if (slotType === 'weapon') {
            validItems = availableItems.filter(item =>
                item.type === 'Weapon' &&
                item.weaponType === character.weaponType &&
                (!item.restrictedTo || item.restrictedTo.includes(character.name))
            );
        } else if (slotType === 'armor1' || slotType === 'armor2') {
            validItems = availableItems.filter(item =>
                item.type === 'Armor' &&
                (!item.restrictedTo || item.restrictedTo.includes(character.name))
            );
        }
        
        // If no valid items, return null
        if (validItems.length === 0) {
            return null;
        }
        
        // Check if all priorities for usable stats are zero
        let allZero = true;
        for (const stat of character.usableStats) {
            if (priorities[stat] > 0) {
                allZero = false;
                break;
            }
        }
        
        // If all priorities are zero, find item with highest combined usable stats
        if (allZero) {
            let bestItem = validItems[0];
            let bestScore = 0;
            
            for (const stat of character.usableStats) {
                bestScore += bestItem[stat] || 0;
            }
            
            for (let i = 1; i < validItems.length; i++) {
                let score = 0;
                for (const stat of character.usableStats) {
                    score += validItems[i][stat] || 0;
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestItem = validItems[i];
                }
            }
            
            return bestItem;
        }
        
        // Otherwise, find the item that maximizes the weighted score based on priorities
        let bestItem = validItems[0];
        let bestScore = 0;
        
        // Calculate score for first item
        for (const stat of character.usableStats) {
            if (priorities[stat] > 0) {
                bestScore += (bestItem[stat] || 0) * priorities[stat];
            }
        }
        
        // Compare with other items
        for (let i = 1; i < validItems.length; i++) {
            let score = 0;
            for (const stat of character.usableStats) {
                if (priorities[stat] > 0) {
                    score += (validItems[i][stat] || 0) * priorities[stat];
                }
            }
            
            if (score > bestScore) {
                bestScore = score;
                bestItem = validItems[i];
            }
        }
        
        return bestItem;
    }
    
    // Function to calculate optimal loadouts for all characters with priorities
    function calculateOptimalLoadoutsWithPriorities(availableItems, allCharacterPriorities, partyMembers) {
        // Create a working copy of the available items
        let currentPool = [...availableItems];
        const loadouts = {};
    
        // Only calculate loadouts for selected party members
        for (const charKey of partyMembers) {
            const character = db.characters[charKey];
            
            // Get character-specific priorities and normalize them
            const rawPriorities = allCharacterPriorities[charKey];
            const normalizedPriorities = normalizePriorities(rawPriorities);
            
            // Find the best weapon for this character
            const bestWeapon = findBestItemForSlot(currentPool, 'weapon', character, normalizedPriorities);
            
            // Create a pool without the weapon (if found)
            let poolWithoutWeapon = currentPool;
            if (bestWeapon) {
                poolWithoutWeapon = currentPool.filter(item => item !== bestWeapon);
            }
            
            // Find the best first armor for this character
            const bestArmor1 = findBestItemForSlot(poolWithoutWeapon, 'armor1', character, normalizedPriorities);
            
            // Create a pool without the weapon and first armor (if found)
            let poolWithoutWeaponAndArmor1 = poolWithoutWeapon;
            if (bestArmor1) {
                poolWithoutWeaponAndArmor1 = poolWithoutWeapon.filter(item => item !== bestArmor1);
            }
            
            // Find the best second armor for this character
            const bestArmor2 = findBestItemForSlot(poolWithoutWeaponAndArmor1, 'armor2', character, normalizedPriorities);
            
            // Create the loadout
            const loadout = {
                weapon: bestWeapon,
                armor1: bestArmor1,
                armor2: bestArmor2,
                totalStats: {
                    at: character.base.at + (bestWeapon?.at || 0) + (bestArmor1?.at || 0) + (bestArmor2?.at || 0),
                    df: character.base.df + (bestWeapon?.df || 0) + (bestArmor1?.df || 0) + (bestArmor2?.df || 0),
                    magic: character.base.magic + (bestWeapon?.magic || 0) + (bestArmor1?.magic || 0) + (bestArmor2?.magic || 0)
                }
            };
            
            // Remove the assigned items from the current pool
            if (bestWeapon) {
                const weaponIndex = currentPool.indexOf(bestWeapon);
                if (weaponIndex !== -1) currentPool.splice(weaponIndex, 1);
            }
            if (bestArmor1) {
                const armor1Index = currentPool.indexOf(bestArmor1);
                if (armor1Index !== -1) currentPool.splice(armor1Index, 1);
            }
            if (bestArmor2) {
                const armor2Index = currentPool.indexOf(bestArmor2);
                if (armor2Index !== -1) currentPool.splice(armor2Index, 1);
            }
            
            loadouts[charKey] = loadout;
        }
    
        return loadouts;
    }
    
    // Function to populate the weapon and armor checklists
    function populateChecklists() {
        const weaponChecklist = document.getElementById('weapon-checklist');
        const armorChecklist = document.getElementById('armor-checklist');
        
        // Clear existing content except the headers
        weaponChecklist.innerHTML = '<h3>Weapons</h3>';
        armorChecklist.innerHTML = '<h3>Armor</h3>';
        
        // Iterate through equipment and create checklist items
        db.equipment.forEach((item, index) => {
            // Create container div for the checkbox, label, and quantity input
            const container = document.createElement('div');
            container.className = 'checklist-item';
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `item-${index}`;
            checkbox.value = item.name;
            checkbox.name = item.name;
            
            // Add data attributes for item properties
            checkbox.dataset.at = item.stats.at || 0;
            checkbox.dataset.df = item.stats.df || 0;
            checkbox.dataset.magic = item.stats.magic || 0;
            checkbox.dataset.type = item.type;
            if (item.weaponType) {
                checkbox.dataset.weaponType = item.weaponType;
            }
            if (item.restrictedTo) {
                checkbox.dataset.restrictedTo = JSON.stringify(item.restrictedTo);
            }
            if (item.unused) {
                checkbox.dataset.unused = true;
            }
            
            // Create label
            const label = document.createElement('label');
            label.htmlFor = `item-${index}`;
            label.textContent = item.name;
            
            // Create quantity input
            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = '1';
            quantityInput.value = '1';
            quantityInput.style.display = 'none';
            quantityInput.className = 'quantity-input';
            quantityInput.id = `quantity-${index}`;
            
            // Add event listener to show/hide quantity input (without saving state)
            checkbox.addEventListener('change', function() {
                if (this.checked) {
                    quantityInput.style.display = 'inline-block';
                } else {
                    quantityInput.style.display = 'none';
                    quantityInput.value = '1'; // Reset to 1 when unchecked
                }
                saveStateToLocalStorage(); // Save state when checkbox is toggled
            });
            
            // Add elements to container
            container.appendChild(checkbox);
            container.appendChild(label);
            container.appendChild(quantityInput);
            
            // Add to appropriate checklist
            if (item.type === 'Weapon') {
                weaponChecklist.appendChild(container);
            } else if (item.type === 'Armor') {
                armorChecklist.appendChild(container);
            }
        });
    }
    
    // Function to save the current state to localStorage
    function saveStateToLocalStorage() {
        const state = {
            party: {},
            items: {},
            priorities: characterPriorities
        };
        
        // Save party member checkbox states
        const partyCheckboxes = document.querySelectorAll('#party-selection input[type="checkbox"]');
        partyCheckboxes.forEach(checkbox => {
            state.party[checkbox.id] = checkbox.checked;
        });
        
        // Save item checkbox states and quantities
        const itemCheckboxes = document.querySelectorAll('#item-selection input[type="checkbox"]');
        itemCheckboxes.forEach(checkbox => {
            const index = checkbox.id.split('-')[1];
            state.items[checkbox.id] = {
                checked: checkbox.checked,
                quantity: document.getElementById(`quantity-${index}`)?.value || '1'
            };
        });
        
        localStorage.setItem('deltaruneLoadoutCalculatorState', JSON.stringify(state));
    }
    
    // Function to load the state from localStorage
    function loadStateFromLocalStorage() {
        const savedState = localStorage.getItem('deltaruneLoadoutCalculatorState');
        if (!savedState) return;
        
        const state = JSON.parse(savedState);
        
        // Load party member checkbox states
        for (const [id, checked] of Object.entries(state.party)) {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = checked;
            }
        }
        
        // Load item checkbox states and quantities
        for (const [id, itemState] of Object.entries(state.items)) {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.checked = itemState.checked;
                
                // Get the index to find the corresponding quantity input
                const index = id.split('-')[1];
                const quantityInput = document.getElementById(`quantity-${index}`);
                
                if (quantityInput) {
                    quantityInput.value = itemState.quantity;
                    
                    // Show quantity input if checkbox is checked
                    if (itemState.checked) {
                        quantityInput.style.display = 'inline-block';
                    }
                }
            }
        }
        
        // Load priority data if available
        if (state.priorities) {
            // Load character priorities
            for (const [character, priorities] of Object.entries(state.priorities)) {
                if (characterPriorities[character]) {
                    characterPriorities[character] = {...priorities};
                }
            }
            // Update UI for currently selected character
            updatePriorityControls();
        }
    }
    
    // Call populateChecklists when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        populateChecklists();
        
        // Load saved state from localStorage
        loadStateFromLocalStorage();
        
        // Add event listeners to party member checkboxes
        const partyCheckboxes = document.querySelectorAll('#party-selection input[type="checkbox"]');
        partyCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                saveStateToLocalStorage(); // Save state when party checkbox changes
            });
        });
        
        // Add event listener to the calculate button
        document.getElementById('calculate-button').addEventListener('click', handleCalculation);
        
        // Add event listeners to all item quantity inputs
        const quantityInputs = document.querySelectorAll('.quantity-input');
        quantityInputs.forEach(input => {
            input.addEventListener('change', function() {
                saveStateToLocalStorage(); // Save state when quantity changes
            });
        });
        
        // Add event listeners for loadout customization
        setupPriorityEventListeners();
        
        // Initialize the UI with the current priorities
        updatePriorityUI();
    });

    // Function to update priority controls based on selected character
    function updatePriorityControls() {
        const selectedCharacter = document.getElementById('character-select').value;
        const container = document.getElementById('priority-controls-container');
        
        // Clear the container
        container.innerHTML = '';
        
        // Clone the template and append to container
        const template = document.getElementById('priority-controls-template');
        const clonedTemplate = template.cloneNode(true);
        clonedTemplate.style.display = 'block';
        clonedTemplate.removeAttribute('id');
        container.appendChild(clonedTemplate);
        
        // Get the character's priorities
        const priorities = characterPriorities[selectedCharacter];
        
        // Update the controls with the character's priorities
        const priorityControls = container.querySelector('.priority-presets');
        const atSlider = container.querySelector('.priority-at');
        const dfSlider = container.querySelector('.priority-df');
        const magicSlider = container.querySelector('.priority-magic');
        const atValue = container.querySelector('.priority-at-value');
        const dfValue = container.querySelector('.priority-df-value');
        const magicValue = container.querySelector('.priority-magic-value');
        
        // Set slider values
        atSlider.value = priorities.at;
        dfSlider.value = priorities.df;
        magicSlider.value = priorities.magic;
        
        // Set display values
        atValue.textContent = priorities.at;
        dfValue.textContent = priorities.df;
        magicValue.textContent = priorities.magic;
        
        // Set preset dropdown to "Custom" by default
        priorityControls.value = 'custom';
        
        // Update preset dropdown to match current priorities if they match a preset
        updatePresetDropdownForCharacter(selectedCharacter);
    }
    
    // Function to update the preset dropdown to match current priorities if they match a preset
    function updatePresetDropdownForCharacter(character) {
        const container = document.getElementById('priority-controls-container');
        const presetDropdown = container.querySelector('.priority-presets');
        const priorities = characterPriorities[character];
        let foundMatch = false;
        
        for (const [presetName, presetValues] of Object.entries(priorityPresets)) {
            if (priorities.at === presetValues[character].at &&
                priorities.df === presetValues[character].df &&
                priorities.magic === presetValues[character].magic) {
                presetDropdown.value = presetName;
                foundMatch = true;
                break;
            }
        }
        
        // If no match found, set to Custom
        if (!foundMatch) {
            presetDropdown.value = 'custom';
        }
    }
    
    // Function to set up event listeners for priority controls
    function setupPriorityEventListeners() {
        // Event listener for character selection dropdown
        document.getElementById('character-select').addEventListener('change', updatePriorityControls);
        
        // Event delegation for dynamically created controls
        document.getElementById('priority-controls-container').addEventListener('change', function(e) {
            const selectedCharacter = document.getElementById('character-select').value;
            
            // Handle preset dropdown change
            if (e.target.classList.contains('priority-presets')) {
                const selectedPreset = e.target.value;
                
                if (priorityPresets[selectedPreset]) {
                    characterPriorities[selectedCharacter] = {...priorityPresets[selectedPreset][selectedCharacter]};
                    updatePriorityControls();
                    saveStateToLocalStorage();
                }
            }
            
            // Handle slider changes
            if (e.target.classList.contains('priority-at')) {
                characterPriorities[selectedCharacter].at = parseInt(e.target.value);
                updatePriorityControls();
                saveStateToLocalStorage();
            }
            
            if (e.target.classList.contains('priority-df')) {
                characterPriorities[selectedCharacter].df = parseInt(e.target.value);
                updatePriorityControls();
                saveStateToLocalStorage();
            }
            
            if (e.target.classList.contains('priority-magic')) {
                characterPriorities[selectedCharacter].magic = parseInt(e.target.value);
                updatePriorityControls();
                saveStateToLocalStorage();
            }
        });
        
        // Event delegation for reset button
        document.getElementById('priority-controls-container').addEventListener('click', function(e) {
            if (e.target.classList.contains('reset-priorities')) {
                const selectedCharacter = document.getElementById('character-select').value;
                characterPriorities[selectedCharacter] = {...priorityPresets['balanced'][selectedCharacter]};
                updatePriorityControls();
                saveStateToLocalStorage();
            }
        });
    }
    
    // Function to update the priority display values
    function updatePriorityDisplay() {
        document.getElementById('priority-at-value').textContent = currentPriorities.at;
        document.getElementById('priority-df-value').textContent = currentPriorities.df;
        document.getElementById('priority-magic-value').textContent = currentPriorities.magic;
    }
    
    // Function to update all priority UI elements
    function updatePriorityUI() {
        // Update slider positions
        document.getElementById('priority-at').value = currentPriorities.at;
        document.getElementById('priority-df').value = currentPriorities.df;
        document.getElementById('priority-magic').value = currentPriorities.magic;
        
        // Update display values
        updatePriorityDisplay();
        
        // Update preset dropdown to match current priorities if they match a preset
        updatePresetDropdown();
    }
    
    // Function to set the preset dropdown to "Custom"
    function setPresetToCustom() {
        const presetDropdown = document.getElementById('priority-presets');
        for (let i = 0; i < presetDropdown.options.length; i++) {
            if (presetDropdown.options[i].value === 'custom') {
                presetDropdown.selectedIndex = i;
                break;
            }
        }
    }
    
    // Function to update the preset dropdown to match current priorities if they match a preset
    function updatePresetDropdown() {
        const presetDropdown = document.getElementById('priority-presets');
        let foundMatch = false;
        
        for (const [presetName, presetValues] of Object.entries(priorityPresets)) {
            if (currentPriorities.at === presetValues.at &&
                currentPriorities.df === presetValues.df &&
                currentPriorities.magic === presetValues.magic) {
                for (let i = 0; i < presetDropdown.options.length; i++) {
                    if (presetDropdown.options[i].value === presetName) {
                        presetDropdown.selectedIndex = i;
                        foundMatch = true;
                        break;
                    }
                }
                break;
            }
        }
        
        // If no match found, set to Custom
        if (!foundMatch) {
            setPresetToCustom();
        }
    }

    // Function to handle the calculation process
    function handleCalculation() {
        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        loadingIndicator.style.display = 'block';
        
        // Gather all checked items and create a pool based on quantities
        const checkedItems = document.querySelectorAll('#item-selection input[type="checkbox"]:checked');
        const availableItems = [];
        
        checkedItems.forEach(checkbox => {
            // Get the index from the checkbox ID to find the corresponding quantity input
            const index = checkbox.id.split('-')[1];
            const quantityInput = document.getElementById(`quantity-${index}`);
            const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
            
            // Create item object
            const item = {
                name: checkbox.value,
                type: checkbox.dataset.type,
                weaponType: checkbox.dataset.weaponType,
                at: parseInt(checkbox.dataset.at) || 0,
                df: parseInt(checkbox.dataset.df) || 0,
                magic: parseInt(checkbox.dataset.magic) || 0,
                restrictedTo: checkbox.dataset.restrictedTo ? JSON.parse(checkbox.dataset.restrictedTo) : null,
                unused: checkbox.dataset.unused === 'true'
            };
            
            // Add multiple instances of the item to the pool based on quantity
            for (let i = 0; i < quantity; i++) {
                availableItems.push({...item}); // Use spread to create a copy
            }
        });
        
        // Identify selected party members
        const selectedParty = [];
        if (document.getElementById('kris-party').checked) selectedParty.push('kris');
        if (document.getElementById('susie-party').checked) selectedParty.push('susie');
        if (document.getElementById('ralsei-party').checked) selectedParty.push('ralsei');
        if (document.getElementById('noelle-party').checked) selectedParty.push('noelle');
        
        // Use setTimeout to make the calculation non-blocking
        setTimeout(() => {
            // Calculate optimal loadouts only for selected party members using the new algorithm
            const loadouts = calculateOptimalLoadoutsWithPriorities(availableItems, characterPriorities, selectedParty);
            
            // Display results
            displayResults(loadouts, selectedParty);
            
            // Hide loading indicator
            loadingIndicator.style.display = 'none';
        }, 0);
    }
    
    // Function to calculate optimal loadouts for all characters with priorities
    function calculateOptimalLoadoutsWithPriorities(availableItems, priorities, partyMembers) {
        // Create a working copy of the available items
        let currentPool = [...availableItems];
        const loadouts = {};
    
        // Only calculate loadouts for selected party members
        for (const charKey of partyMembers) {
            const character = db.characters[charKey];
            
            // Find the best weapon for this character
            const bestWeapon = findBestItemForSlot(currentPool, 'weapon', character, priorities);
            
            // Create a pool without the weapon (if found)
            let poolWithoutWeapon = currentPool;
            if (bestWeapon) {
                poolWithoutWeapon = currentPool.filter(item => item !== bestWeapon);
            }
            
            // Find the best first armor for this character
            const bestArmor1 = findBestItemForSlot(poolWithoutWeapon, 'armor1', character, priorities);
            
            // Create a pool without the weapon and first armor (if found)
            let poolWithoutWeaponAndArmor1 = poolWithoutWeapon;
            if (bestArmor1) {
                poolWithoutWeaponAndArmor1 = poolWithoutWeapon.filter(item => item !== bestArmor1);
            }
            
            // Find the best second armor for this character
            const bestArmor2 = findBestItemForSlot(poolWithoutWeaponAndArmor1, 'armor2', character, priorities);
            
            // Create the loadout
            const loadout = {
                weapon: bestWeapon,
                armor1: bestArmor1,
                armor2: bestArmor2,
                totalStats: {
                    at: character.base.at + (bestWeapon?.at || 0) + (bestArmor1?.at || 0) + (bestArmor2?.at || 0),
                    df: character.base.df + (bestWeapon?.df || 0) + (bestArmor1?.df || 0) + (bestArmor2?.df || 0),
                    magic: character.base.magic + (bestWeapon?.magic || 0) + (bestArmor1?.magic || 0) + (bestArmor2?.magic || 0)
                }
            };
            
            // Remove the assigned items from the current pool
            if (bestWeapon) {
                const weaponIndex = currentPool.indexOf(bestWeapon);
                if (weaponIndex !== -1) currentPool.splice(weaponIndex, 1);
            }
            if (bestArmor1) {
                const armor1Index = currentPool.indexOf(bestArmor1);
                if (armor1Index !== -1) currentPool.splice(armor1Index, 1);
            }
            if (bestArmor2) {
                const armor2Index = currentPool.indexOf(bestArmor2);
                if (armor2Index !== -1) currentPool.splice(armor2Index, 1);
            }
            
            loadouts[charKey] = loadout;
        }
    
        return loadouts;
    }
    
    // Function to display the calculated results
    function displayResults(loadouts, selectedParty) {
        // Define all character keys
        const allCharacters = ['kris', 'susie', 'ralsei', 'noelle'];
        
        // Iterate through all characters
        for (const charKey of allCharacters) {
            const resultsContainer = document.getElementById(`${charKey}-results`);
            
            // Check if character is in the selected party
            if (selectedParty.includes(charKey)) {
                // Character is in party, display their loadout
                const loadout = loadouts[charKey];
                
                // Clear existing content
                resultsContainer.innerHTML = `<h3>${db.characters[charKey].name}</h3>`;
                
                // Create and populate results content
                const weaponName = loadout.weapon ? loadout.weapon.name : 'None';
                const armor1Name = loadout.armor1 ? loadout.armor1.name : 'None';
                const armor2Name = loadout.armor2 ? loadout.armor2.name : 'None';
                
                const statsHTML = `
                    <p><strong>Weapon:</strong> ${weaponName}</p>
                    <p><strong>Armor 1:</strong> ${armor1Name}</p>
                    <p><strong>Armor 2:</strong> ${armor2Name}</p>
                    <div class="stats-display">
                        <div class="stat">
                            <div class="label">AT</div>
                            <div class="value">${loadout.totalStats.at}</div>
                        </div>
                        <div class="stat">
                            <div class="label">DF</div>
                            <div class="value">${loadout.totalStats.df}</div>
                        </div>
                        <div class="stat">
                            <div class="label">MG</div>
                            <div class="value">${loadout.totalStats.magic}</div>
                        </div>
                    </div>
                `;
                
                resultsContainer.innerHTML += statsHTML;
                resultsContainer.style.display = 'block'; // Show the container
            } else {
                // Character is not in party, hide their results
                resultsContainer.style.display = 'none';
            }
        }
        
        // Show the results container
        document.getElementById('results-container').style.display = 'block';
    }
</script>
</body>
</html>